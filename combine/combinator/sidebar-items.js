initSidebarItems({"fn":[["and_then","Equivalent to [`p.and_then(f)`]."],["any","Parses any token."],["between","Parses `open` followed by `parser` followed by `close`. Returns the value of `parser`."],["chainl1","Parses `p` 1 or more times separated by `op`. The value returned is the one produced by the left associative application of the function returned by the parser `op`."],["chainr1","Parses `p` one or more times separated by `op`. The value returned is the one produced by the right associative application of the function returned by `op`."],["choice","Takes an array of parsers and tries to apply them each in order. Fails if all the parsers fails or if an applied parser consumes input before failing."],["count","Parses `parser` from zero up to `count` times."],["count_min_max","Parses `parser` from `min` to `max` times (including `min` and `max`)."],["env_parser","Constructs a parser out of an environment and a function which needs the given environment to do the parsing. This is commonly useful to allow multiple parsers to share some environment while still allowing the parsers to be written in separate functions."],["eof","Succeeds only if the stream is at end of input, fails otherwise."],["expected","Equivalent to [`p.expected(info)`]."],["flat_map","Equivalent to [`p.flat_map(f)`]."],["look_ahead","`look_ahead(p)` acts as `p` but doesn't consume input on success."],["many","Parses `p` zero or more times returning a collection with the values from `p`."],["many1","Parses `p` one or more times returning a collection with the values from `p`."],["map","Equivalent to [`p.map(f)`]."],["message","Equivalent to [`p1.message(msg)`]."],["none_of","Extract one token and succeeds if it is not part of `tokens`."],["not_followed_by","Succeeds only if `parser` fails. Never consumes any input."],["one_of","Extract one token and succeeds if it is part of `tokens`."],["optional","Parses `parser` and outputs `Some(value)` if it succeeds, `None` if it fails without consuming any input. Fails if `parser` fails after having consumed some input."],["or","Equivalent to [`p1.or(p2)`]."],["parser","Wraps a function, turning it into a parser."],["position","Parser which just returns the current position in the stream."],["recognize","Constructs a parser which returns the tokens parsed by `parser` accumulated in `F: FromIterator<P::Input::Item>` instead of `P::Output`."],["satisfy","Parses a token and succeeds depending on the result of `predicate`."],["satisfy_map","Parses a token and passes it to `predicate`. If `predicate` returns `Some` the parser succeeds and returns the value inside the `Option`. If `predicate` returns `None` the parser fails without consuming any input."],["sep_by","Parses `parser` zero or more time separated by `separator`, returning a collection with the values from `p`."],["sep_by1","Parses `parser` one or more time separated by `separator`, returning a collection with the values from `p`."],["sep_end_by","Parses `parser` zero or more times separated and ended by `separator`, returning a collection with the values from `p`."],["sep_end_by1","Parses `parser` one or more times separated and ended by `separator`, returning a collection with the values from `p`."],["skip",""],["skip_count","Parses `parser` from zero up to `count` times skipping the output of `parser`."],["skip_count_min_max","Parses `parser` from `min` to `max` times (including `min` and `max`) skipping the output of `parser`."],["skip_many","Parses `p` zero or more times ignoring the result."],["skip_many1","Parses `p` one or more times ignoring the result."],["then","Equivalent to [`p.then(f)`]."],["token","Parses a character and succeeds if the character is equal to `c`."],["tokens","Parses multiple tokens."],["try","`try(p)` behaves as `p` except it acts as if the parser hadn't consumed any input if `p` fails after consuming input."],["unexpected","Always fails with `message` as an unexpected error. Never consumes any input."],["value","Always returns the value `v` without consuming any input."],["with","Equivalent to [`p1.with(p2)`]."]],"struct":[["AndThen",""],["Any",""],["Between",""],["Chainl1",""],["Chainr1",""],["Choice",""],["Count",""],["CountMinMax",""],["EnvParser",""],["Eof",""],["Expected",""],["FlatMap",""],["FnParser",""],["Iter",""],["LookAhead",""],["Many",""],["Many1",""],["Map",""],["Message",""],["NoneOf",""],["OneOf",""],["Optional",""],["Or",""],["Position",""],["Recognize",""],["Satisfy",""],["SatisfyMap",""],["SepBy",""],["SepBy1",""],["SepEndBy",""],["SepEndBy1",""],["Skip",""],["SkipMany",""],["SkipMany1",""],["Then",""],["Token",""],["Tokens",""],["Try",""],["Unexpected",""],["Value",""],["With",""]],"type":[["NotFollowedBy",""],["SkipCount",""],["SkipCountMinMax",""]]});